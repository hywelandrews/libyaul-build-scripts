#!/bin/bash
{
# Copyright (c) 2012-2016
# See LICENSE for details.
#
# Israel Jacquez <mrkotfw@gmail.com>
# Dave Murphy <davem@devkitpro.org>

PROGNAME=`basename "${0}"`

CONFIG_FILENAME="config"
CONFIG_IN_FILENAME="config.in"
CONFIG_PATH="./${CONFIG_FILENAME}"

# Function message:
#   ${@} => Message
function message() {
    local _message="${@}"

    printf -- "${_message}\n"
}

# Function panic:
#   ${1} => Message
#   ${2} => Exit status code
function panic() {
    local _message="${1}"
    local _exit_code=${2}

    printf -- "${PROGNAME}: Error: %s\n" "${_message}" 1>&2
    exit ${_exit_code}
}

source="${BASH_source[0]}"
while [ -h "${source}" ]; do # Resolve ${source} until the file is no longer a symlink
    ROOT="$(cd -P "$(dirname "${source}")" && pwd)"
    source="$(readlink "${source}")"
    # If ${source} was a relative symlink, we need to resolve it
    # relative to the path where the symlink file was located
    [[ ${source} != /* ]] && source="${ROOT}/${source}"
done
ROOT="$(cd -P "$(dirname "${source}" )" && pwd)"
unset source

if [[ "${ROOT}" != "`pwd`" ]]; then
    panic "You must be in \`${ROOT}' in order to invoke ${PROGNAME}"
fi

# Look for automated configuration file
if [ -f "${CONFIG_PATH}" ]; then
    error_line=$(/usr/bin/env python << EOF
from re import match

line_no = 0
with open("${CONFIG_PATH}", "r") as f:
    for line in f.readlines():
        line_no += 1
        # Ignore comments and empty lines
        if match(r"^\s*#.*$|^\s*$", line.strip()):
            continue
        if not match(r"^[A-Z_][A-Z_0-9]+=(?:\"[^\"]*\"|[0-9]+)$", line.strip()):
            print line_no,
            raise SystemExit
EOF
)
    if [ ${?} -ne 0 ]; then
        panic "Syntax error in configuration file \`${CONFIG_FILENAME}' on line ${error_line}" 1
    fi
    unset error_line

    source "${CONFIG_PATH}" > /dev/null 2>&1
else
    panic "Configuration file \`${CONFIG_FILENAME}' not found; see \`${CONFIG_IN_FILENAME}'" 1
fi

# Function is_var_set:
#   ${1} => Variable
function is_var_set() {
    if [[ ! "${!1}" && "${!1-_}" ]]; then
        panic "Variable \"${1}\" does not exist in your config file" 1
    fi
}

# Function check_boolean:
#   ${1} => Value
function check_boolean() {
    if [[ "${!1}" != "no" && "${!1}" != "yes" ]]; then
        panic "Variable \"${1}\" has an invalid value in your config file" 1
    fi
}

# Function program_exists
#   ${1} => Program name
function program_exists() {
    local _program_name="${1}"

    if ! command -v "${_program_name}" >/dev/null 2>&1; then
        panic "Program \"${_program_name}\" does not exist in \${PATH}" 1
    fi
}

# Function fetch:
#   ${1} => URL
function fetch() {
    local _url="${1}"

    "${FETCH}" "${FETCH_FLAGS}" "${_url}"
    local _exit_code=${?}

    case "${FETCH}" in
        wget)
            # Kludge: It looks like GNU Wget doesn't return the
            # correct exit status code.
            if [ ${_exit_code} -ge 2 ] && [ ${_exit_code} -le 8 ]; then
                return 1
            fi
            return 0
            ;;
        *)
            return ${_exit_code}
    esac
}

# Function checksum_gpg:
#   ${1} => File (.sig file)
function checksum_gpg() {
    local _file="${1}"

    "${GPG}" --verify --keyring "${BUILD_SRC_DIR}/${GNU_KEYRING}" "${_file}"
    local _exit_code=${?}
    return ${_exit_code}
}

# Function clean_up:
#
function clean_up() {
    if [ -z "${BUILD_SRC_DIR}" ]; then
        exit 1
    fi

    message "Cleaning up '${BUILD_SRC_DIR}'"

    for target in ${TARGETS[@]}; do
        rm -r -f "${BUILD_SRC_DIR}/${target}"
    done

    exit 0
}

# Function apply_patch:
#   ${1} => Target
#   ${2} => Type
#   ${3} => Patch filename
function apply_patch() {
    local _target="${1}"
    local _type="${2}"
    local _patch="${3}"

    local _patch_filename="${_type}-${_patch}"

    if [ ! -f "${BUILD_SRC_DIR}/${_target}/applied-patches-${_type}" ]; then
        message "Applying patch '${_patch_filename}'"

        # Determine if we can patch
        test -f "${_target}/patches/${_patch_filename}" \
            && (patch -d "${BUILD_SRC_DIR}/${_target}" --dry-run -p 0 < \
                      "${_target}/patches/${_patch_filename}")  1> /dev/null 2>&1 \
            || panic "Couldn't apply patch" 1

        # Patch
        patch -d "${BUILD_SRC_DIR}/${_target}" -p 0 < \
              "${_target}/patches/${_patch_filename}" 1> /dev/null 2>&1

        touch "${BUILD_SRC_DIR}/${_target}/applied-patches-${_type}"
    fi
}

# Function build_target:
#
function build_target() {
    if [ -f "${target}/scripts/init" ]; then
        source "${target}/scripts/init"
    fi

    if [ -f "${target}/scripts/extract" ]; then
        source "${target}/scripts/extract"
    fi

    if [ -f "${target}/scripts/patch" ]; then
        source "${target}/scripts/patch"
    fi

    if [ -f "${target}/scripts/build" ]; then
        source "${target}/scripts/build"
    fi

    if [ -f "${target}/scripts/strip" ]; then
        source "${target}/scripts/strip"
    fi

    if [ -f "${target}/scripts/finish" ]; then
        source "${target}/scripts/finish"
    fi
}

trap 'exit_code=${?}; clean_up; exit ${exit_code}' 1 9 15

for var in \
    "OPTION_DOWNLOAD_TARBALLS" \
    "OPTION_ENABLE_GDB"; do
    is_var_set "${var}"
    check_boolean "${var}"
done
unset var

for var in \
    "BUILD_HOST" \
    "BUILD_TARGETS" \
    "GNU_URL" \
    "BUILD_INSTALL_DIR" \
    "BUILD_SRC_DIR" \
    "BINUTILS_VERSION" \
    "BUILD_MAKE_JOBS" \
    "BUILD_SUPPORT_LIBS" \
    "GCC_VERSION" \
    "GDB_VERSION" \
    "MAKE" \
    "AWK" \
    "GPG" \
    "MD5" \
    "PATCH" \
    "FETCH" \
    "FETCH_FLAGS"; do
    is_var_set "${var}"
done
unset var

for program in \
    "MAKE" \
    "AWK" \
    "GPG" \
    "MD5" \
    "PATCH" \
    "FETCH"; do
    program_exists "${!program}"
done
unset program

TARGETS=(`printf -- "${BUILD_TARGETS}" | sed -E 's/[[:space:]]+/ /g'`)

if [ ${#TARGETS[@]} -eq 0 ]; then
    panic "Invalid build target(s)" 1
fi

GCC="gcc-${GCC_VERSION}.tar.bz2"
GCC_URL="${GNU_URL}/gcc/gcc-${GCC_VERSION}/${GCC}"
GCC_SIG="${GCC}.sig"
GCC_SIG_URL="${GNU_URL}/gcc/gcc-${GCC_VERSION}/${GCC_SIG}"
GCC_SRC_DIR="gcc-${GCC_VERSION}"

BINUTILS="binutils-${BINUTILS_VERSION}.tar.bz2"
BINUTILS_URL="${GNU_URL}/binutils/${BINUTILS}"
BINUTILS_SIG="${BINUTILS}.sig"
BINUTILS_SIG_URL="${GNU_URL}/binutils/${BINUTILS_SIG}"
BINUTILS_SRC_DIR="binutils-${BINUTILS_VERSION}"

GDB="gdb-${GDB_VERSION}.tar.bz2"
GDB_URL="${GNU_URL}/gdb/${GDB}"
GDB_SIG="${GDB}.sig"
GDB_SIG_URL="${GNU_URL}/gdb/${GDB_SIG}"
GDB_SRC_DIR="gdb-${GDB_VERSION}"

GNU_KEYRING="gnu-keyring.gpg"
GNU_KEYRING_URL="${GNU_URL}/${GNU_KEYRING}"

# Get preferred installation directory and set paths to the sources
# Make sure we have the proper permissions
mkdir -p "${BUILD_INSTALL_DIR}" 1> /dev/null 2>&1 && \
    test -x "${BUILD_INSTALL_DIR}" && \
    test -w "${BUILD_INSTALL_DIR}" && \
    test -r "${BUILD_INSTALL_DIR}" || \
    panic "Couldn't create install directory" 1

if ! [ -d "${BUILD_SRC_DIR}" ]; then
    panic "Path \`${BUILD_SRC_DIR}/' is non-existent" 1
fi

cd "${BUILD_SRC_DIR}/" 2> /dev/null
if [[ "${OPTION_DOWNLOAD_TARBALLS}" == "no" ]]; then
    message "Be sure to have the following files in ${BUILD_SRC_DIR}:"
    printf -- "\n\t1. ${GNU_KEYRING}"
    printf -- "\n\t2. ${BINUTILS}"
    printf -- "\n\t3. ${BINUTILS_SIG}"
    printf -- "\n\t4. ${GCC}"
    printf -- "\n\t5. ${GCC_SIG}"
    printf -- "\n\t8. ${GDB}"
    printf -- "\n\t9. ${GDB_SIG}"
    printf -- "\n"
    printf -- "\n"
else
    if [ ! -f "${BUILD_SRC_DIR}/downloaded-tarballs" ]; then
        message "Downloading files..."

        if [ ! -f "${BINUTILS}" ]; then
            message "Downloading \`${BINUTILS}'"
            if ! fetch "${BINUTILS_URL}" 1>> "binutils.log" 2>&1; then
                panic "Failed to download ${BINUTILS} from ${BINUTILS_URL} (see \`${BUILD_SRC_DIR}/binutils.log')" 1
            fi
        fi
        if [ ! -f "${BINUTILS_SIG}" ]; then
            if ! fetch "${BINUTILS_SIG_URL}" 1>> "binutils.log" 2>&1; then
                panic "Failed to download ${BINUTILS_SIG} (see \`${BUILD_SRC_DIR}/binutils.log')" 1
            fi
        fi

        if [ ! -f "${GCC}" ]; then
            message "Downloading \`${GCC}'"
            if ! fetch "${GCC_URL}"  1>> "gcc.log" 2>&1; then
                panic "Failed to download ${GCC} from ${GCC_URL} (see \`${BUILD_SRC_DIR}/gcc.log')" 1
            fi
        fi
        if [ ! -f "${GCC_SIG}" ]; then
            if ! fetch "${GCC_SIG_URL}" 1>> "gcc.log" 2>&1; then
                panic "Failed to download ${GCC_SIG} from ${GCC_SIG_URL}) (see \`${BUILD_SRC_DIR}/gcc.log')" 1
            fi
        fi

        if [[ "${OPTION_ENABLE_GDB}" == "yes" ]]; then
            if [ ! -f "${GDB}" ]; then
                message "Downloading \`${GDB}'"
                if ! fetch "${GDB_URL}" 1>> "gdb.log" 2>&1; then
                    panic "Failed to download ${GDB} from ${GDB_URL} (see \`${BUILD_SRC_DIR}/gdb.log')" 1
                fi
            fi
            if [ ! -f "${GDB_SIG}" ]; then
                if ! fetch "${GDB_SIG_URL}" 1>> "gdb.log" 2>&1; then
                    panic "Failed to download ${GDB_SIG} from ${GDB_SIG_URL} (see \`${BUILD_SRC_DIR}/gdb.log')" 1
                fi
            fi
        fi

        if [ ! -f "${GNU_KEYRING}" ]; then
            message "Downloading \`${GNU_KEYRING}'"
            if ! fetch "${GNU_KEYRING_URL}"  1>> "gcc.log" 2>&1; then
                panic "Failed to download ${GNU_KEYRING} from ${GNU_KEYRING_URL} (see \`${BUILD_SRC_DIR}/gcc.log')" 1
            fi
        fi

        touch "downloaded-tarballs"
    fi
fi

if [ ! -f "${BUILD_SRC_DIR}/checked-integrity" ]; then
    if [ ! -f "${GNU_KEYRING}" ]; then
        panic "\`${GNU_KEYRING}' not found"
    fi

    if [ ! -f "${BINUTILS}" ]; then
        panic "\`${BINUTILS}' not found" 1
    fi
    if [ ! -f "${BINUTILS_SIG}" ]; then
        panic "\`${BINUTILS_SIG}' not found" 1
    fi

    if [ ! -f "${GCC}" ]; then
        panic "\`${GCC}' not found" 1
    fi
    if [ ! -f "${GCC_SIG}" ]; then
        panic "\`${GCC_SIG}' not found" 1
    fi

    if [[ "${OPTION_ENABLE_GDB}" == "yes" ]]; then
        if [ ! -f "${GDB}" ]; then
            panic "\`${GDB}' not found" 1
        fi
        if [ ! -f "${GDB_SIG}" ]; then
            panic "\`${GDB_SIG}' not found" 1
        fi
    fi

    message "Checking integrity..."

    # Check integrity
    message "Checking integrity of \`${BINUTILS}'"
    if ! checksum_gpg "${BINUTILS_SIG}" 1>> "binutils.log" 2>&1; then
        panic "Integrity check for ${BINUTILS} failed (see \`${BUILD_SRC_DIR}/binutils.log')" 1
    fi

    message "Checking integrity of \`${GCC}'"
    if ! checksum_gpg "${GCC_SIG}" 1>> "gcc.log" 2>&1; then
        panic "Integrity check for ${GCC} failed (see \`${BUILD_SRC_DIR}/gcc.log')" 1
    fi

    if [[ "${OPTION_ENABLE_GDB}" == "yes" ]]; then
        message "Checking integrity of \`${GDB}'"
        if ! checksum_gpg "${GDB_SIG}" 1>> "gdb.log" 2>&1; then
            panic "Integrity check for ${GDB} failed (see \`${BUILD_SRC_DIR}/gdb.log')" 1
        fi
    fi

    touch "checked-integrity"
fi
cd - 1> /dev/null

message "Building targets: `echo ${TARGETS[@]} | sed -E 's/ /, /g'`"

for target in ${TARGETS[@]}; do
    if [ -f "${BUILD_SRC_DIR}/${target}/build-complete" ]; then
        continue
    fi

    if ! [ -z "${BUILD_HOST}" ]; then
        # In order to build a Canadian Cross build-x-host-x-target,
        # you need to first build the build-x-host cross-compiler and
        # the build-x-target cross-compiler.

        export PATH="${BUILD_SRC_DIR}/build-x-target/${target}/bin:${PATH}"

        # We need to check if we're done building
        if true; then
            message "Building build-x-target (${target})"

            (BUILD_HOST=""
             BUILD_INSTALL_DIR="${BUILD_SRC_DIR}/build-x-target"

             build_target
             clean_up) || exit ${?}
        fi
    else
        export PATH="${BUILD_INSTALL_DIR}/${target}/bin:${PATH}"
    fi

    message "Building build-x-host-x-target (${target})"

    build_target
done
}
